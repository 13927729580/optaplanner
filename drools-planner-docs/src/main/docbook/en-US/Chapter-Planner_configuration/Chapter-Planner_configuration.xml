<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Planner configuration</title>

  <section>
    <title>Overview</title>

    <para>Solving a planning problem with Drools Planner consists out of 5 steps:</para>

    <orderedlist>
      <listitem>
        <para><emphasis role="bold">Model your planning problem</emphasis> as a class that implements the interface
        <literal>Solution</literal>, for example the class <literal>NQueens</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Configure a <literal>Solver</literal></emphasis>, for example a first fit and tabu
        search solver for any <literal>NQueens</literal> instance.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Load a problem data set</emphasis> from your data layer, for example a 4 Queens
        instance. Set it as the planning problem on the <literal>Solver</literal> with
        <literal>Solver.setPlanningProblem(...)</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Solve it</emphasis> with <literal>Solver.solve()</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Get the best solution found</emphasis> by the <literal>Solver</literal> with
        <literal>Solver.getBestSolution()</literal>.</para>
      </listitem>
    </orderedlist>
  </section>

  <section>
    <title>Solver configuration</title>

    <section>
      <title>Solver configuration by XML file</title>

      <para>You can build a <literal>Solver</literal> instance with the <literal>XmlSolverFactory</literal>. Configure
      it with a solver configuration XML file:</para>

      <programlisting language="java">        XmlSolverFactory solverFactory = new XmlSolverFactory();
        solverFactory.configure("/org/drools/planner/examples/nqueens/solver/nqueensSolverConfig.xml");
        Solver solver = solverFactory.buildSolver();</programlisting>

      <para>A solver configuration file looks something like this:</para>

      <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;org.drools.planner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;planningEntityClass&gt;org.drools.planner.examples.nqueens.domain.Queen&lt;/planningEntityClass&gt;

  &lt;!-- Define the score function --&gt;
  &lt;scoreDrl&gt;/org/drools/planner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
  &lt;scoreDefinition&gt;
    &lt;scoreDefinitionType&gt;SIMPLE&lt;/scoreDefinitionType&gt;
  &lt;/scoreDefinition&gt;

  &lt;!-- Configure the optimization algorithm(s) --&gt;
  &lt;termination&gt;
    ...
  &lt;/termination&gt;
  &lt;constructionHeuristic&gt;
    ...
  &lt;/constructionHeuristic&gt;
  &lt;localSearch&gt;
    ...
  &lt;/localSearch&gt;
&lt;/solver&gt;</programlisting>

      <para>Notice the 3 parts in it:</para>

      <itemizedlist>
        <listitem>
          <para>Define the model</para>
        </listitem>

        <listitem>
          <para>Define the score function</para>
        </listitem>

        <listitem>
          <para>Configure the optimization algorithm(s)</para>
        </listitem>
      </itemizedlist>

      <para>We 'll explain these various parts of a configuration later in this manual.</para>

      <para><emphasis role="bold">Drools Planner makes it relatively easy to switch optimization algorithm(s) just by
      changing the configuration.</emphasis> There's even a <literal>Benchmark</literal> utility which allows you to
      play out different configurations against each other and report the most appropriate configuration for your
      problem. You could for example play out tabu search versus simulated annealing, on 4 queens and 64 queens.</para>
    </section>

    <section>
      <title>Solver configuration by Java API</title>

      <para>As an alternative to the XML file, a solver configuration can also be configured with the
      <literal>SolverConfig</literal> API:</para>

      <programlisting language="java">        SolverConfig solverConfig = new SolverConfig();

        solverConfig.setSolutionClass(NQueens.class);
        Set&lt;Class&lt;?&gt;&gt; planningEntityClassSet = new HashSet&lt;Class&lt;?&gt;&gt;();
        planningEntityClassSet.add(Queen.class);
        solverConfig.setPlanningEntityClassSet(planningEntityClassSet);

        solverConfig.setScoreDrlList(
                Arrays.asList("/org/drools/planner/examples/nqueens/solver/nQueensScoreRules.drl"));
        ScoreDefinitionConfig scoreDefinitionConfig = solverConfig.getScoreDefinitionConfig();
        scoreDefinitionConfig.setScoreDefinitionType(
                ScoreDefinitionConfig.ScoreDefinitionType.SIMPLE);

        TerminationConfig terminationConfig = solverConfig.getTerminationConfig();
        // ...
        List&lt;SolverPhaseConfig&gt; solverPhaseConfigList = new ArrayList&lt;SolverPhaseConfig&gt;();
        ConstructionHeuristicSolverPhaseConfig constructionHeuristicSolverPhaseConfig
                = new ConstructionHeuristicSolverPhaseConfig();
        // ...
        solverPhaseConfigList.add(constructionHeuristicSolverPhaseConfig);
        LocalSearchSolverPhaseConfig localSearchSolverPhaseConfig = new LocalSearchSolverPhaseConfig();
        // ...
        solverPhaseConfigList.add(localSearchSolverPhaseConfig);
        solverConfig.setSolverPhaseConfigList(solverPhaseConfigList);
        Solver solver = solverConfig.buildSolver();</programlisting>

      <para><emphasis role="bold">It is highly recommended to configure by XML file instead of this API.</emphasis> To
      dynamically configure a value at runtime, use the XML file as a template and extract the
      <literal>SolverConfig</literal> class with <literal>getSolverConfig()</literal> to configure the dynamic value at
      runtime:</para>

      <programlisting language="java">        XmlSolverFactory solverFactory = new XmlSolverFactory();
        solverFactory.configure("/org/drools/planner/examples/nqueens/solver/nqueensSolverConfig.xml");

        SolverConfig solverConfig = solverFactory.getSolverConfig();
        solverConfig.getTerminationConfig().setMaximumMinutesSpend(userInput);
        Solver solver = solverConfig.buildSolver();</programlisting>
    </section>
  </section>

  <section>
    <title>Model your planning problem</title>

    <section>
      <title>Is this class a problem fact or planning entity?</title>

      <para>Look at a dataset of your planning problem. You 'll recognize domain classes in there, each of which is one
      of these:</para>

      <itemizedlist>
        <listitem>
          <para>A unrelated class: not used by any of the score constraints. From a planning standpoint, this data is
          obsolete.</para>
        </listitem>

        <listitem>
          <para>A <emphasis role="bold">problem fact</emphasis> class: used by the score constraints, but does NOT
          change during planning (as long as the problem stays the same). For example: <literal>Bed</literal>,
          <literal>Room</literal>, <literal>Shift</literal>, <literal>Employee</literal>, <literal>Topic</literal>,
          <literal>Period</literal>, ...</para>
        </listitem>

        <listitem>
          <para>A <emphasis role="bold">planning entity</emphasis> class: used by the score constraints and changes
          during planning. For example: <literal>BedDesignation</literal>, <literal>ShiftAssignment</literal>,
          <literal>Exam</literal>, ...</para>
        </listitem>
      </itemizedlist>

      <para>Ask yourself: <emphasis>What class changes during planning?</emphasis> <emphasis>Which class has variables
      that I want the <literal>Solver</literal> to choose for me?</emphasis> That class is a planning entity. Most use
      cases have only 1 planning entity class.</para>

      <note>
        <para>In <link linkend="realTimePlanning">real-time planning</link>, problem facts can change during planning,
        because the problem itself changes. However, that doesn't make them planning entities.</para>
      </note>

      <para><emphasis role="bold">In Drools Planner all problems facts and planning entities are plain old JavaBeans
      (POJO's).</emphasis> You can load them from a database (JDBC/JPA/JDO), an XML file, a data repository, a noSQL
      cloud, ...: Drools Planner doesn't care.</para>
    </section>

    <section>
      <title>Problem fact</title>

      <para>A problem fact is any JavaBean (POJO) with getters that does not change during planning. Implementing the
      interface <literal>Serializable</literal> is recommended (but not required). For example in n queens, the columns
      and rows are problem facts:</para>

      <programlisting language="java">public class Column implements Serializable {

    private int index;

    // ... getters
}</programlisting>

      <programlisting language="java">public class Row implements Serializable {

    private int index;

    // ... getters
}</programlisting>

      <para>A problem fact can reference other problem facts of course:</para>

      <programlisting language="java">public class Course implements Serializable {

    private String code;

    private Teacher teacher; // Other problem fact
    private int lectureSize;
    private int minWorkingDaySize;

    private List&lt;Curriculum&gt; curriculumList; // Other problem facts
    private int studentSize;

    // ... getters
}</programlisting>

      <para>A problem fact class does <emphasis>not</emphasis> require any Planner specific code. For example, you can
      reuse your domain classes, which might have JPA annotations.</para>

      <note>
        <para>Generally, better designed domain classes lead to simpler and more efficient score constraints. Therefore,
        when dealing with a messy legacy system, it can sometimes be worth it to convert the messy domain set into a
        planner specific POJO set first. For example: if your domain model has 2 <literal>Teacher</literal> instances
        for the same teacher that teaches at 2 different departments, it's hard to write a correct score constraint that
        constrains a teacher's spare time.</para>

        <para>Alternatively, you can sometimes also introduce <link linkend="cachedProblemFact"><emphasis>a cached
        problem fact</emphasis></link> to enrich the domain model for planning only.</para>
      </note>
    </section>

    <section>
      <title>Planning entity and planning variables</title>

      <section>
        <title>Planning entity</title>

        <para>A planning entity is a JavaBean (POJO) that changes during solving, for example a <literal>Queen</literal>
        that changes to another row. A planning problem has multiple planning entities, for example for a single n
        queens problem, each <literal>Queen</literal> is a planning entity. But there's usually only 1 planning entity
        class, for example the <literal>Queen</literal> class.</para>

        <para>A planning entity class needs to be annotated with the <literal>@PlanningEntity</literal>
        annotation.</para>

        <para>Each planning entity class has 1 or more <emphasis>planning variables</emphasis>. It usually also has 1 or
        more <emphasis>defining</emphasis> properties. For example in n queens, a <literal>Queen</literal> is defined by
        its <literal>Column</literal> and has a planning variable <literal>Row</literal>. This means that a Queen's
        column never changes during solving, while its row does change.</para>

        <programlisting language="java">@PlanningEntity
public class Queen {

    private Column column;

    // Planning variables: changes during planning, between score calculations.
    private Row row;

    // ... getters and setters
}</programlisting>

        <para>A planning entity class can have multiple planning variables. For example, a <literal>Lecture</literal> is
        defined by its <literal>Course</literal> and its index in that course (because 1 course has multiple lectures).
        Each <literal>Lecture</literal> needs to be scheduled into a <literal>Period</literal> and a
        <literal>Room</literal> so it has 2 planning variables (period and room). For example: the course Mathematics
        has 8 lectures per week, of which the first lecture is Monday morning at 08:00 in room 212.</para>

        <programlisting language="java">@PlanningEntity
public class Lecture {

    private Course course;
    private int lectureIndexInCourse;

    // Planning variables: changes during planning, between score calculations.
    private Period period;
    private Room room;

    // ...
}</programlisting>

        <para>The solver configuration also needs to be made aware of each planning entity class:</para>

        <programlisting language="java">&lt;solver&gt;
  ...
  &lt;planningEntityClass&gt;org.drools.planner.examples.nqueens.domain.Queen&lt;/planningEntityClass&gt;
  ...
&lt;/solver&gt;</programlisting>

        <para>Some uses cases have multiple planning entity classes. For example: route freight and trains into railway
        network arcs, where each freight can use multiple trains over its journey and each train can carry multiple
        freights per arc. Having multiple planning entity classes directly raises the implementation complexity of your
        use case.</para>

        <note>
          <para><emphasis>Do not create unnecessary planning entity classes.</emphasis> This leads to difficult
          <literal>Move</literal> implementations and slower score calculation.</para>

          <para>For example, do not create a planning entity class to hold the total free time of a teacher, which needs
          to be kept up to date as the <literal>Lecture</literal> planning entities change. Instead, calculate the free
          time in the score constraints and put the result per teacher into a logically inserted score object.</para>

          <para>If historic data needs to be considered too, then create problem fact to hold the historic data up to,
          but <emphasis>not including</emphasis>, the planning window (so it doesn't change when a planning entity
          changes) and let the score constraints take it into account.</para>
        </note>
      </section>

      <section xml:id="planningEntityDifficulty">
        <title>Planning entity difficulty</title>

        <para>Some optimization algorithms work more efficiently if they have an estimation of which planning entities
        are more difficult to plan. For example: in bin packing bigger items are harder to fit, in course scheduling
        lectures with more students are more difficult to schedule and in n queens the middle queens are more
        difficult.</para>

        <para>Therefore, you can set a <literal>difficultyComparatorClass</literal> to the
        <literal>@PlanningEntity</literal> annotation:</para>

        <programlisting language="java">@PlanningEntity(difficultyComparatorClass = CloudProcessAssignmentDifficultyComparator.class)
public class CloudProcessAssignment {
    // ...
}</programlisting>

        <programlisting language="java">public class CloudProcessAssignmentDifficultyComparator implements Comparator&lt;CloudProcessAssignment&gt; {

    public int compare(CloudProcessAssignment a, CloudProcessAssignment b) {
        return new CompareToBuilder()
                .append(a.getCloudProcess().getRequiredMultiplicand(), b.getCloudProcess().getRequiredMultiplicand())
                .append(a.getCloudProcess().getId(), b.getCloudProcess().getId())
                .toComparison();
    }

}</programlisting>

        <note>
          <para>If you have multiple planning entity classes, the <literal>difficultyComparatorClass</literal> needs to
          implement a <literal>Comparator</literal> of a common superclass (for example
          <literal>Comparator&lt;Object&gt;</literal>) and be able to handle comparing instances of those different
          classes.</para>
        </note>

        <para>Alternatively, you can also set a <literal>difficultyWeightFactoryClass</literal> to the
        <literal>@PlanningEntity</literal> annotation, so you have access to the rest of the problem facts from the
        solution too:</para>

        <programlisting language="java">@PlanningEntity(difficultyWeightFactoryClass = QueenDifficultyWeightFactory.class)
public class Queen {
    // ...
}</programlisting>

        <programlisting language="java">public interface PlanningEntityDifficultyWeightFactory {

    Comparable createDifficultyWeight(Solution solution, Object planningEntity);

}</programlisting>

        <programlisting language="java">public class QueenDifficultyWeightFactory implements PlanningEntityDifficultyWeightFactory {

    public Comparable createDifficultyWeight(Solution solution, Object planningEntity) {
        NQueens nQueens = (NQueens) solution;
        Queen queen = (Queen) planningEntity;
        int distanceFromMiddle = calculateDistanceFromMiddle(nQueens.getN(), queen.getColumnIndex());
        return new QueenDifficultyWeight(queen, distanceFromMiddle);
    }

    // ...

    public static class QueenDifficultyWeight implements Comparable&lt;QueenDifficultyWeight&gt; {

        private final Queen queen;
        private final int distanceFromMiddle;

        public QueenDifficultyWeight(Queen queen, int distanceFromMiddle) {
            this.queen = queen;
            this.distanceFromMiddle = distanceFromMiddle;
        }

        public int compareTo(QueenDifficultyWeight other) {
            return new CompareToBuilder()
                    // The more difficult queens have a lower distance to the middle
                    .append(other.distanceFromMiddle, distanceFromMiddle) // Decreasing
                    .append(queen.getColumnIndex(), other.queen.getColumnIndex())
                    .toComparison();
        }

    }

}</programlisting>

        <para><emphasis>None of the current planning variable state may be used to compare planning entities.</emphasis>
        They are likely to be <literal>null</literal> anyway. For example, a <literal>Queen</literal>'s
        <literal>row</literal> variable may not be used.</para>
      </section>

      <section>
        <title>Planning variable</title>

        <para>A planning variable is a property (including getter and setter) on a planning entity. It changes during
        planning. For example, a <literal>Queen</literal>'s <literal>row</literal> property is a planning variable. Note
        that even though a <literal>Queen</literal>'s <literal>row</literal> property changes to another
        <literal>Row</literal> during planning, no <literal>Row</literal> instance itself is changed. A planning
        variable points to a planning value.</para>

        <para>A planning variable getter needs to be annotated with the <literal>@PlanningVariable</literal> annotation.
        Furthermore, it needs a <literal>@ValueRange</literal> annotation too.</para>

        <programlisting language="java">@PlanningEntity
public class Queen {

    private Row row;

    // ...

    @PlanningVariable
    @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = rowList")
    public Row getRow() {
        return row;
    }

    public void setRow(Row row) {
        this.row = row;
    }

}</programlisting>
      </section>

      <section>
        <title>When is a planning entity initialized?</title>

        <para>A planning entity is considered initialized if all its planning variables are initialized.</para>

        <para>By default, a planning variable is considered initialized if its value is not
        <literal>null</literal>.</para>
      </section>
    </section>

    <section>
      <title>Planning value and planning value ranges</title>

      <section>
        <title>Planning value</title>

        <para>A planning value is a possible value for a planning variable. Usually, a planning value is problem fact,
        but it can also be any object, for example a double. It can even be another planning entity or even a interface
        implemented by a planning entity and a problem fact.</para>

        <para>A planning value range is the set of possible planning values for a planning variable. This set can be a
        discrete (for example row <literal>1</literal>, <literal>2</literal>, <literal>3</literal> or
        <literal>4</literal>) or continuous (for example any <literal>double</literal> between <literal>0.0</literal>
        and <literal>1.0</literal>). There are several ways to define the value range of a planning variable with the
        <literal>@ValueRange</literal> annotation.</para>

        <para>If <literal>null</literal> is a valid planning value, it should be included in the value range and the
        default way to detect uninitialized planning variables must be changed.</para>
      </section>

      <section>
        <title>Planning value range</title>

        <section>
          <title><literal>ValueRange</literal> from <literal>Solution</literal> property</title>

          <para>All instances of the same planning entity class share the same set of possible planning values for that
          planning variable. This is the most common way to configure a value range.</para>

          <para>The <literal>Solution</literal> implementation has property which returns a
          <literal>Collection</literal>. Any value from that <literal>Collection</literal> is a possible planning value
          for this planning variable.</para>

          <programlisting language="java">    @PlanningVariable
    @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = "rowList")
    public Row getRow() {
        return row;
    }</programlisting>

          <programlisting language="java">public class NQueens implements Solution&lt;SimpleScore&gt; {

    // ...

    public List&lt;Row&gt; getRowList() {
        return rowList;
    }

}</programlisting>
        </section>

        <section>
          <title><literal>ValueRange</literal> from planning entity</title>

          <para>Each planning entity has its own set of possible planning values for a planning variable. For example,
          if a teacher can <emphasis role="bold">never</emphasis> teach in a room that does not belong to his
          department, lectures of that teacher can limit their room value range to the rooms of his department.</para>

          <programlisting language="java">    @PlanningVariable
    @ValueRange(type = ValueRangeType.FROM_PLANNING_ENTITY_PROPERTY, planningEntityProperty = "possibleRoomList")
    public Room getRoom() {
        return room;
    }

    public List&lt;Room&gt; getPossibleRoomList() {
        return getCourse().getTeacher().getPossibleRoomList();
    }</programlisting>

          <para>Never use this to enforce a soft constraint (or even a hard constraint when the problem might not have a
          feasible solution). For example: <emphasis>Unless there is no other way</emphasis>, a teacher can not teach in
          a room that does not belong to his department. In this case, the teacher should <emphasis>not</emphasis> be
          limited in his room value range (because sometimes there is no other way).</para>

          <note>
            <para>By limiting the value range specifically of 1 planning entity, you are effectively making a
            <emphasis>build-in hard constraint</emphasis>. This can be a very good thing, as the number of possible
            solutions is severely lowered. But this can also be a bad thing because it takes away the freedom of the
            optimization algorithms to temporarily break such a hard constraint.</para>
          </note>

          <para>A planning entity should <emphasis>not</emphasis> use other planning entities to determinate its value
          range. That would only try to make it solve the planning problem itself and interfere with the optimization
          algorithms.</para>
        </section>

        <section>
          <title><literal>ValueRange</literal> undefinied</title>

          <para>Leaves the value range undefined. Some optimization algorithms do not support this value
          range.</para>

          <programlisting language="java">    @PlanningVariable
    @ValueRange(type = ValueRangeType.UNDEFINED)
    public Row getRow() {
        return row;
    }</programlisting>
        </section>

        <section>
          <title>Combining ValueRanges</title>

          <para>Value ranges can be combined, for example:</para>

          <programlisting language="java">    @PlanningVariable(...)
    @ValueRanges({
            @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = "companyCarList"),
            @ValueRange(type = ValueRangeType.FROM_PLANNING_ENTITY_PROPERTY, planningEntityProperty = "personalCarList"})
    public Car getCar() {
        return car;
    }</programlisting>
        </section>

        <section>
          <title>A <literal>ValueRange</literal> which includes other planning entities</title>

          <para>In some cases (such as in chaining), the planning value itself is sometimes another planning entity. In
          such cases, it's often required that a planning entity is only eligible as a planning value if it's
          initialized:</para>

          <programlisting language="java">    @PlanningVariable
    @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = "copList", excludeUninitializedPlanningEntity = true)
    public Cop getPartner() {
        return partner;
    }</programlisting>

          <para>TODO: this is likely to change in the future (<link
          xlink:href="https://issues.jboss.org/browse/JBRULES-3408">jira</link>), as it should support specific planning
          variable initialization too.</para>
        </section>

        <section>
          <title>Chained</title>

          <para>Some use cases, such as TSP and Vehicle Routing, require <emphasis>chaining</emphasis>. This means the
          planning entities point to each other and form a chain.</para>

          <para>A variable that is chained either:</para>

          <itemizedlist>
            <listitem>
              <para>Directly points to a planning fact, which is called an <emphasis>anchor</emphasis>.</para>
            </listitem>

            <listitem>
              <para>Points to another planning entity with the same planning variable, which recursively points to an
              anchor.</para>
            </listitem>
          </itemizedlist>

          <para>Here are some example of valid and invalid chains:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter-Planner_configuration/chainPrinciples.png"></imagedata>
            </imageobject>
          </mediaobject>

          <para><emphasis role="bold">Every initialized planning entity is part of an open-ended chain that begins from
          an anchor.</emphasis> A valid model means that:</para>

          <itemizedlist>
            <listitem>
              <para>A chain is never a loop. The tail is always open.</para>
            </listitem>

            <listitem>
              <para>Every chain always has exactly 1 anchor. The anchor is a problem fact, never a planning
              entity.</para>
            </listitem>

            <listitem>
              <para>A chain is never a tree, it is always a line. Every anchor or planning entity has at most 1 trailing
              planning entity.</para>
            </listitem>

            <listitem>
              <para>Every initialized planning entity is part of a chain.</para>
            </listitem>

            <listitem>
              <para>An anchor with no planning entities pointing to it, is also considered a chain.</para>
            </listitem>
          </itemizedlist>

          <warning>
            <para>A planning problem instance given to the <literal>Solver</literal> must be valid.</para>
          </warning>

          <note>
            <para>If your constraints dictate a closed chain, model it as an open-ended chain (which is easier to
            persist in a database) and implement a score constraint for the last entity back to the anchor.</para>
          </note>

          <para>The optimization algorithms and build-in <literal>MoveFactory</literal>'s do chain correction to
          guarantee that the model stays valid:</para>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter-Planner_configuration/chainCorrection.png"></imagedata>
            </imageobject>
          </mediaobject>

          <warning>
            <para>A custom <literal>Move</literal> implementation must leave the model in a valid state.</para>
          </warning>

          <para>For example, in TSP the anchor is a <literal>Domicile</literal> (in vehicle routing it is the
          vehicle):</para>

          <programlisting language="java">public class Domicile ... implements Appearance {

    ...

    public City getCity() {...}

}</programlisting>

          <para>The anchor (which is a problem fact) and the planning entity implement a common interface, for example
          TSP's <literal>Appearance</literal>:</para>

          <programlisting language="java">public interface Appearance {

    City getCity();

}</programlisting>

          <para>That interface is the return type of the planning variable. Furthermore, the planning variable is
          chained. For example TSP's <literal>Visit</literal> (in vehicle routing it is the customer):</para>

          <programlisting language="java">@PlanningEntity
public class Visit ... implements Appearance {

    ...

    public City getCity() {...}

    @PlanningVariable(chained = true)
    @ValueRanges({
            @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = "domicileList"),
            @ValueRange(type = ValueRangeType.FROM_SOLUTION_PROPERTY, solutionProperty = "visitList",
                    excludeUninitializedPlanningEntity = true)})
    public Appearance getPreviousAppearance() {
        return previousAppearance;
    }

    public void setPreviousAppearance(Appearance previousAppearance) {
        this.previousAppearance = previousAppearance;
    }

}</programlisting>

          <para>Notice how 2 value ranges need to be combined:</para>

          <itemizedlist>
            <listitem>
              <para>The value range which holds the anchors, for example <literal>domicileList</literal>.</para>
            </listitem>

            <listitem>
              <para>The value range which holds the initialized planning entities, for example
              <literal>visitList</literal>. This always requires an enabled
              <literal>excludeUninitializedPlanningEntity</literal>, because an intialized entity should never point to
              an unintialized entity: that would break the principle that every chain must have an anchor.</para>
            </listitem>
          </itemizedlist>
        </section>
      </section>

      <section xml:id="planningValueStrength">
        <title>Planning value strength</title>

        <para>Some optimization algorithms work more efficiently if they have an estimation of which planning values are
        stronger, which means they are more likely to satisfy a planning entity. For example: in bin packing bigger
        containers are more likely to fit an item and in course scheduling bigger rooms are less likely to break the
        student capacity constraint.</para>

        <para>Therefore, you can set a <literal>strengthComparatorClass</literal> to the
        <literal>@PlanningVariable</literal> annotation:</para>

        <programlisting language="java">    @PlanningVariable(strengthComparatorClass = CloudComputerStrengthComparator.class)
    // ...
    public CloudComputer getCloudComputer() {
        // ...
    }</programlisting>

        <programlisting language="java">public class CloudComputerStrengthComparator implements Comparator&lt;CloudComputer&gt; {

    public int compare(CloudComputer a, CloudComputer b) {
        return new CompareToBuilder()
                .append(a.getMultiplicand(), b.getMultiplicand())
                .append(b.getCost(), a.getCost()) // Descending (but this is debatable)
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</programlisting>

        <note>
          <para>If you have multiple planning value classes in the <emphasis>same</emphasis> value range, the
          <literal>strengthComparatorClass</literal> needs to implement a <literal>Comparator</literal> of a common
          superclass (for example <literal>Comparator&lt;Object&gt;</literal>) and be able to handle comparing instances
          of those different classes.</para>
        </note>

        <para>Alternatively, you can also set a <literal>strengthWeightFactoryClass</literal> to the
        <literal>@PlanningVariable</literal> annotation, so you have access to the rest of the problem facts from the
        solution too:</para>

        <programlisting language="java">    @PlanningVariable(strengthWeightFactoryClass = RowStrengthWeightFactory.class)
    // ...
    public Row getRow() {
        // ...
    }</programlisting>

        <programlisting language="java">public interface PlanningValueStrengthWeightFactory {

    Comparable createStrengthWeight(Solution solution, Object planningValue);

}</programlisting>

        <programlisting language="java">public class RowStrengthWeightFactory implements PlanningValueStrengthWeightFactory {

    public Comparable createStrengthWeight(Solution solution, Object planningValue) {
        NQueens nQueens = (NQueens) solution;
        Row row = (Row) planningValue;
        int distanceFromMiddle = calculateDistanceFromMiddle(nQueens.getN(), row.getIndex());
        return new RowStrengthWeight(row, distanceFromMiddle);
    }

    // ...

    public static class RowStrengthWeight implements Comparable&lt;RowStrengthWeight&gt; {

        private final Row row;
        private final int distanceFromMiddle;

        public RowStrengthWeight(Row row, int distanceFromMiddle) {
            this.row = row;
            this.distanceFromMiddle = distanceFromMiddle;
        }

        public int compareTo(RowStrengthWeight other) {
            return new CompareToBuilder()
                    // The stronger rows have a lower distance to the middle
                    .append(other.distanceFromMiddle, distanceFromMiddle) // Decreasing (but this is debatable)
                    .append(row.getIndex(), other.row.getIndex())
                    .toComparison();
        }

    }

}</programlisting>

        <para><emphasis>None of the current planning variable state in any of the planning entities may be used to
        compare planning values.</emphasis> They are likely to be <literal>null</literal> anyway. For example, None of
        the <literal>row</literal> variables of any <literal>Queen</literal> may be used to determine the strength of a
        <literal>Row</literal>.</para>
      </section>
    </section>

    <section>
      <title>Planning problem and planning solution</title>

      <section>
        <title>Planning problem instance</title>

        <para>A dataset for a planning problem needs to be wrapped in a class for the <literal>Solver</literal> to
        solve. You must implement this class. For example in n queens, this in the <literal>NQueens</literal> class
        which contains a <literal>Column</literal> list, a <literal>Row</literal> list and a <literal>Queen</literal>
        list.</para>

        <para>A planning problem is actually a unsolved planning solution or - stated differently - an uninitialized
        <literal>Solution</literal>. Therefor, that wrapping class must implement the <literal>Solution</literal>
        interface. For example in n queens, that <literal>NQueens</literal> class implements
        <literal>Solution</literal>, yet every <literal>Queen</literal> in a fresh <literal>NQueens</literal> class is
        assigned to a <literal>Row</literal> yet. So it's not a feasible solution. It's not even a possible solution.
        It's an uninitialized solution.</para>
      </section>

      <section>
        <title>The <literal>Solution</literal> interface</title>

        <para>You need to present the problem as a <literal>Solution</literal> instance to the
        <literal>Solver</literal>. So you need to have a class that implements the <literal>Solution</literal>
        interface:</para>

        <programlisting language="java">public interface Solution&lt;S extends Score&gt; {

    S getScore();
    void setScore(S score);

    Collection&lt;? extends Object&gt; getProblemFacts();

    Solution&lt;S&gt; cloneSolution();

}</programlisting>

        <para>For example, an <literal>NQueens</literal> instance holds a list of all columns, all rows and all
        <literal>Queen</literal> instances:</para>

        <programlisting language="java">public class NQueens implements Solution&lt;SimpleScore&gt; {

    private int n;

    // Problem facts
    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    // Planning entities
    private List&lt;Queen&gt; queenList;

    // ...
}</programlisting>
      </section>

      <section>
        <title>The getScore and setScore methods</title>

        <para>A <literal>Solution</literal> requires a score property. The score property is <literal>null</literal> if
        the <literal>Solution</literal> is uninitialized or if the score has not yet been (re)calculated. The score
        property is usually typed to the specific <literal>Score</literal> implementation you use. For example,
        <literal>NQueens</literal> uses a <literal>SimpleScore</literal>:</para>

        <programlisting language="java">public class NQueens implements Solution&lt;SimpleScore&gt; {

    private SimpleScore score;

    public SimpleScore getScore() {
        return score;
    }

    public void setScore(SimpleScore score) {
        this.score = score;
    }

    // ...
}</programlisting>

        <para>Most use cases use a <literal>HardAndSoftScore</literal> instead:</para>

        <programlisting language="java">public class CurriculumCourseSchedule implements Solution&lt;HardAndSoftScore&gt; {

    private HardAndSoftScore score;

    public HardAndSoftScore getScore() {
        return score;
    }

    public void setScore(HardAndSoftScore score) {
        this.score = score;
    }

    // ...
}</programlisting>

        <para>See the Score calculation section for more information on the <literal>Score</literal>
        implementations.</para>
      </section>

      <section xml:id="getProblemFacts">
        <title>The getProblemFacts method</title>

        <para>All objects returned by the <literal>getProblemFacts()</literal> method will be asserted into the drools
        working memory, so the score rules can access them. For example, <literal>NQueens</literal> just returns all
        <literal>Column</literal> and <literal>Row</literal> instances.</para>

        <programlisting language="java">    public Collection&lt;? extends Object&gt; getProblemFacts() {
        List&lt;Object&gt; facts = new ArrayList&lt;Object&gt;();
        facts.addAll(columnList);
        facts.addAll(rowList);
        // Do not add the planning entity's (queenList) because that will be done automatically
        return facts;
    }</programlisting>

        <para><emphasis>All planning entities are automatically inserted into the drools working memory.</emphasis> Do
        not add them in the method <literal>getProblemFacts()</literal>.</para>

        <para>The method <literal>getProblemFacts()</literal> is not called much: at most only once per solver phase per
        solver thread.</para>
      </section>

      <section xml:id="cachedProblemFact">
        <title>Cached problem fact</title>

        <para>A cached problem fact is a problem fact that doesn't exist in the real domain model, but is calculated
        before the <literal>Solver</literal> really starts solving. The method <literal>getProblemFacts()</literal> has
        the chance to enrich the domain model with such cached problem facts, which can lead to simpler and faster score
        constraints.</para>

        <para>For example in examination, a cache problem fact <literal>TopicConflict</literal> is created for every 2
        <literal>Topic</literal>'s which share at least 1 <literal>Student</literal>.</para>

        <programlisting language="java">    public Collection&lt;? extends Object&gt; getProblemFacts() {
        List&lt;Object&gt; facts = new ArrayList&lt;Object&gt;();
        // ...
        facts.addAll(calculateTopicConflictList());
        // ...
        return facts;
    }

    private List&lt;TopicConflict&gt; calculateTopicConflictList() {
        List&lt;TopicConflict&gt; topicConflictList = new ArrayList&lt;TopicConflict&gt;();
        for (Topic leftTopic : topicList) {
            for (Topic rightTopic : topicList) {
                if (leftTopic.getId() &lt; rightTopic.getId()) {
                    int studentSize = 0;
                    for (Student student : leftTopic.getStudentList()) {
                        if (rightTopic.getStudentList().contains(student)) {
                            studentSize++;
                        }
                    }
                    if (studentSize &gt; 0) {
                        topicConflictList.add(new TopicConflict(leftTopic, rightTopic, studentSize));
                    }
                }
            }
        }
        return topicConflictList;
    }</programlisting>

        <para>Any score constraint that needs to check if no 2 exams have a topic which share a student are being
        scheduled close together (depending on the constraint: at the same time, in a row or in the same day), can
        simply use the <literal>TopicConflict</literal> instance as a problem fact, instead of having to combine every 2
        <literal>Student</literal> instances.</para>
      </section>

      <section>
        <title>The cloneSolution method</title>

        <para>Most optimization algorithms use the <literal>cloneSolution()</literal> method to clone the solution each
        time they encounter a new best solution (so they can recall it later) or to work with multiple solutions in
        parallel.</para>

        <para>The <literal>NQueens</literal> implementation only deep clones all <literal>Queen</literal> instances.
        When the original solution is changed during planning, by changing a <literal>Queen</literal>, the clone stays
        the same.</para>

        <programlisting language="java">    /**
     * Clone will only deep copy the {@link #queenList}.
     */
    public NQueens cloneSolution() {
        NQueens clone = new NQueens();
        clone.id = id;
        clone.n = n;
        clone.columnList = columnList;
        clone.rowList = rowList;
        List&lt;Queen&gt; clonedQueenList = new ArrayList&lt;Queen&gt;(queenList.size());
        for (Queen queen : queenList) {
            clonedQueenList.add(queen.clone());
        }
        clone.queenList = clonedQueenList;
        clone.score = score;
        return clone;
    }</programlisting>

        <para><emphasis>The <literal>cloneSolution()</literal> method should only deep clone the planning
        entities.</emphasis> Notice that the problem facts, such as <literal>Column</literal> and <literal>Row</literal>
        are normally <emphasis>not</emphasis> cloned: even their <literal>List</literal> instances are
        <emphasis>not</emphasis> cloned.</para>

        <note>
          <para>If you were to clone the problem facts too, then you'd have to make sure that the new planning entity
          clones also refer to the new problem facts clones used by the solution. For example, if you 'd clone all
          <literal>Row</literal> instances, then each <literal>Queen</literal> clone and the <literal>NQueens</literal>
          clone itself should refer to the same set of new <literal>Row</literal> clones.</para>
        </note>
      </section>

      <section>
        <title>Build an uninitialized solution</title>

        <para>Build a <literal>Solution</literal> instance to represent your planning problem, so you can set it on the
        <literal>Solver</literal> as the planning problem to solve. For example in n queens, an
        <literal>NQueens</literal> instance is created with the required <literal>Column</literal> and
        <literal>Row</literal> instances and every <literal>Queen</literal> set to a different <literal>column</literal>
        and every <literal>row</literal> set to <literal>null</literal>.</para>

        <programlisting language="java">    private NQueens createNQueens(int n) {
        NQueens nQueens = new NQueens();
        nQueens.setId(0L);
        nQueens.setN(n);
        List&lt;Column&gt; columnList = new ArrayList&lt;Column&gt;(n);
        for (int i = 0; i &lt; n; i++) {
            Column column = new Column();
            column.setId((long) i);
            column.setIndex(i);
            columnList.add(column);
        }
        nQueens.setColumnList(columnList);
        List&lt;Row&gt; rowList = new ArrayList&lt;Row&gt;(n);
        for (int i = 0; i &lt; n; i++) {
            Row row = new Row();
            row.setId((long) i);
            row.setIndex(i);
            rowList.add(row);
        }
        nQueens.setRowList(rowList);
        List&lt;Queen&gt; queenList = new ArrayList&lt;Queen&gt;(n);
        long id = 0;
        for (Column column : columnList) {
            Queen queen = new Queen();
            queen.setId(id);
            id++;
            queen.setColumn(column);
            // Notice that we leave the PlanningVariable properties (row) on null
            queenList.add(queen);
        }
        nQueens.setQueenList(queenList);
        return nQueens;
    }</programlisting>

        <figure>
          <title>Uninitialized solution for the 4 queens puzzle</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Chapter-Planner_configuration/uninitializedNQueens04.png" format="PNG"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Usually, most of this data comes from your data layer, and your <literal>Solution</literal> implementation
        just aggregates that data and creates the uninitialized planning entity instances to plan:</para>

        <programlisting language="java">        private void createLectureList(CurriculumCourseSchedule schedule) {
            List&lt;Course&gt; courseList = schedule.getCourseList();
            List&lt;Lecture&gt; lectureList = new ArrayList&lt;Lecture&gt;(courseList.size());
            for (Course course : courseList) {
                for (int i = 0; i &lt; course.getLectureSize(); i++) {
                    Lecture lecture = new Lecture();
                    lecture.setCourse(course);
                    lecture.setLectureIndexInCourse(i);
                    // Notice that we leave the PlanningVariable properties (period and room) on null
                    lectureList.add(lecture);
                }
            }
            schedule.setLectureList(lectureList);
        }</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Use the <literal>Solver</literal></title>

    <section>
      <title>The Solver interface</title>

      <para>A <literal>Solver</literal> implementation will solve your planning problem.</para>

      <programlisting language="java">public interface Solver {

    void setPlanningProblem(Solution planningProblem);
    
    void solve();

    Solution getBestSolution();

    // ...

}</programlisting>

      <para>A <literal>Solver</literal> can only solve 1 planning problem instance at a time. A
      <literal>Solver</literal> should only be accessed from a single thread, except for the methods that are
      specifically javadocced as being thread-safe. It's build with a <literal>SolverFactory</literal>, do not implement
      or build it yourself.</para>
    </section>

    <section>
      <title>Solving a problem</title>

      <para>Solving a problem is quite easy once you have:</para>

      <itemizedlist>
        <listitem>
          <para>A <literal>Solver</literal> build from a solver configuration</para>
        </listitem>

        <listitem>
          <para>A <literal>Solution</literal> that represents the planning problem instance</para>
        </listitem>
      </itemizedlist>

      <para>Just set the planning problem, solve it and extract the best solution:</para>

      <programlisting language="java">    solver.setPlanningProblem(planningProblem);
    solver.solve();
    Solution bestSolution = solver.getBestSolution();</programlisting>

      <para>For example in n queens, the method <literal>getBestSolution()</literal> will return an
      <literal>NQueens</literal> instance with every <literal>Queen</literal> assigned to a
      <literal>Row</literal>.</para>

      <figure>
        <title>Best solution for the 4 queens puzzle in 8 ms (also an optimal solution)</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Planner_configuration/solvedNQueens04.png" format="PNG"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>The <literal>solve()</literal> method can take a long time (depending on the problem size and the solver
      configuration). The <literal>Solver</literal> will remember (actually clone) the best solution it encounters
      during its solving. Depending on a number factors (including problem size, how time the <literal>Solver</literal>
      has, the solver configuration, ...), that best solution will be a feasible or even an optimal solution.</para>

      <note>
        <para>The <literal>Solution</literal> instance given to the method <literal>setPlanningProblem()</literal> will
        be changed by the <literal>Solver</literal>, but it do not mistake it for the best solution.</para>

        <para>The <literal>Solution</literal> instance returned by the method <literal>getBestSolution()</literal> will
        most likely be a clone of the instance given to the method <literal>setPlanningProblem()</literal>, which means
        it's a different instance.</para>
      </note>

      <note>
        <para>The <literal>Solution</literal> instance given to the method <literal>setPlanningProblem()</literal> does
        not need to be uninitialized. It can be partially or fully initialized, which is likely in <link
        linkend="repeatedPlanning">repeated planning</link>.</para>
      </note>
    </section>

    <section>
      <title>Environment mode: Are there bugs in my code?</title>

      <para>The environment mode allows you to detect common bugs in your implementation. It does not affect the logging
      level.</para>

      <para>You can set the environment mode in the solver configuration XML file:</para>

      <programlisting language="xml">&lt;solver&gt;
  &lt;environmentMode&gt;DEBUG&lt;/environmentMode&gt;
  ...
&lt;/solver&gt;</programlisting>

      <para>A solver has a single <literal>Random</literal> instance. Some solver configurations use the
      <literal>Random</literal> instance a lot more than others. For example simulated annealing depends highly on
      random numbers, while tabu search only depends on it to deal with score ties. The environment mode influences the
      seed of that <literal>Random</literal> instance.</para>

      <para>There are 4 environment modes:</para>

      <section>
        <title>TRACE</title>

        <para>The trace mode is reproducible (see the reproducible mode) and also turns on all assertions (such as
        assert that the delta based score is uncorrupted) to fail-fast on rule engine bugs.</para>

        <para>The trace mode is very slow (because it doesn't rely on delta based score calculation).</para>
      </section>

      <section>
        <title>DEBUG</title>

        <para>The debug mode is reproducible (see the reproducible mode) and also turns on most assertions (such as
        assert that the undo Move is uncorrupted) to fail-fast on a bug in your Move implementation, your score rule,
        ...</para>

        <para>The debug mode is slow.</para>

        <para>It's recommended to write a test case which does a short run of your planning problem with debug mode
        on.</para>
      </section>

      <section>
        <title>REPRODUCIBLE (default)</title>

        <para>The reproducible mode is the default mode because it is recommended during development. In this mode, 2
        runs in the same Planner version will execute the same code in the same order. <emphasis role="bold">Those 2
        runs will have the same result</emphasis>, except if they rely on time based termination and they have a
        sufficiently large difference in allocated CPU time. This allows you to consistently reproduce bugs. It also
        allows you to benchmark certain refactorings (such as a score constraint optimization) fairly across
        runs.</para>

        <para>The reproducible mode is not much slower than the production mode. If your production environment requires
        reproducability, use it in production too.</para>

        <para>In practice, this mode uses the default random seed, and it also disables certain concurrency
        optimizations (such as work stealing).</para>
      </section>

      <section>
        <title>PRODUCTION</title>

        <para>The production mode is the fastest and the most robust, but not reproducible. It is recommended for a
        production environment.</para>

        <para>The random seed is different on every run, which makes it more robust against an unlucky random seed. An
        unlucky random seed gives a bad result on a certain data set with a certain solver configuration. Note that in
        most use cases the impact of the random seed is relatively low on the result (even with simulated annealing). An
        occasional bad result is far more likely caused by another issue (such as a score trap).</para>
      </section>
    </section>

    <section>
      <title>Logging level: What is the <literal>Solver</literal> doing?</title>

      <para>The best way to illuminate the black box that is a <literal>Solver</literal>, is to play with the logging
      level:</para>

      <itemizedlist>
        <listitem>
          <para><emphasis role="bold">ERROR</emphasis>: When something is wrong, Planner fails fast: it throws a
          subclass of <literal>RuntimeException</literal> with a detailed message to the calling code, but does not log
          an error message to avoid duplicate log messages. If the calling code doesn't catch and eat that
          <literal>RuntimeException</literal>, a <literal>Thread</literal>'s default <literal>ExceptionHandler</literal>
          will log it as an error anyway.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">WARN</emphasis>: Log suspicous circumstances.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">INFO</emphasis>: Log every phase and the solver itself.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">DEBUG</emphasis>: Log every step of every phase.</para>
        </listitem>

        <listitem>
          <para><emphasis role="bold">TRACE</emphasis>: Log every move of every step of every phase.</para>
        </listitem>
      </itemizedlist>

      <para>For example, set it to <literal>DEBUG</literal> logging, to see when the phases end and how fast steps are
      taken:</para>

      <programlisting>INFO  Solving started: time spend (0), score (null), new best score (null), random seed (0).
DEBUG     Step index (0), time spend (1), score (0), initialized planning entity (col2@row0).
DEBUG     Step index (1), time spend (3), score (0), initialized planning entity (col1@row2).
DEBUG     Step index (2), time spend (4), score (0), initialized planning entity (col3@row3).
DEBUG     Step index (3), time spend (5), score (-1), initialized planning entity (col0@row1).
INFO  Phase constructionHeuristic finished: step total (4), time spend (6), best score (-1).
DEBUG     Step index (0), time spend (10), score (-1),     best score (-1), accepted move size (12) for picked step (col1@row2 =&gt; row3).
DEBUG     Step index (1), time spend (12), score (0), new best score (0), accepted move size (12) for picked step (col3@row3 =&gt; row2).
INFO  Phase localSearch ended: step total (2), time spend (13), best score (0).
INFO  Solving ended: time spend (13), best score (0), average calculate count per second (4846).</programlisting>

      <para>All time spends are in milliseconds.</para>

      <para>Everything is logged to <link xlink:href="http://www.slf4j.org/">SLF4J</link>, which is a simple logging
      facade that can delegate any log to Logback, Apache Commons Logging, Log4j or java.util.logging. Add a dependency
      to the logging adaptor for your logging framework of choice. If you're not using any logging framework yet, you
      can use Logback by adding this Maven dependency:</para>

      <programlisting language="xml">    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>

      <para>Configure the logging level on the package <literal>org.drools.planner</literal>. For example:</para>

      <para>In Logback, configure it in your <filename>logback.xml</filename> file:</para>

      <programlisting language="xml">&lt;configuration&gt;

  &lt;logger name="org.drools.planner" level="debug"/&gt;

  ...

&lt;configuration&gt;</programlisting>

      <para>In Log4J, configure it in your <filename>log4j.xml</filename> file:</para>

      <programlisting language="xml">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;

  &lt;category name="org.drools.planner"&gt;
    &lt;priority value="debug" /&gt;
  &lt;/category&gt;

  ...

&lt;/log4j:configuration&gt;</programlisting>
    </section>
  </section>
</chapter>
