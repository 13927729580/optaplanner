<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Planner configuration</title>

  <section>
    <title>Overview</title>

    <para>Solving a planning problem with Drools Planner consists out of 5 steps:</para>

    <orderedlist>
      <listitem>
        <para><emphasis role="bold">Model your planning problem</emphasis> as a class that implements the interface
        <literal>Solution</literal>, for example the class <literal>NQueens</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Configure a <literal>Solver</literal></emphasis>, for example a first fit and tabu
        search solver for any <literal>NQueens</literal> instance.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Load a <literal>Solution</literal> instance</emphasis> from your data layer, for
        example a 4 Queens instance. Set it as the starting solution on the <literal>Solver</literal> with
        <literal>Solver.setStartingSolution(...)</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Solve it</emphasis> with <literal>Solver.solve()</literal>.</para>
      </listitem>

      <listitem>
        <para><emphasis role="bold">Get the best solution found</emphasis> by the <literal>Solver</literal> with
        <literal>Solver.getBestSolution()</literal>.</para>
      </listitem>
    </orderedlist>
  </section>

  <section>
    <title>Model your planning problem</title>

    <section>
      <title>Is this class a problem fact or planning entity?</title>

      <para>Look at a dataset of your planning problem. You 'll recognize domain classes in there, each of which is one
      of these:</para>

      <itemizedlist>
        <listitem>
          <para>A unrelated class: not used by any of the score constraints. From a planning standpoint, this data is
          obsolete.</para>
        </listitem>

        <listitem>
          <para>A <emphasis role="bold">problem fact</emphasis> class: used by the score constraints, but does NOT
          change during planning (as long as the problem stays the same). For example: <literal>Bed</literal>,
          <literal>Room</literal>, <literal>Shift</literal>, <literal>Employee</literal>, <literal>Topic</literal>,
          <literal>Period</literal>, ...</para>
        </listitem>

        <listitem>
          <para>A <emphasis role="bold">planning entity</emphasis> class: used by the score constraints and changes
          during planning. For example: <literal>BedDesignation</literal>, <literal>Assignment</literal>,
          <literal>Exam</literal>, ...</para>
        </listitem>
      </itemizedlist>

      <para>Ask yourself: <emphasis>What class changes during planning?</emphasis> <emphasis>Which class has variables
      that I want the <literal>Solver</literal> to choose for me?</emphasis> That class is a planning entity. Most use
      cases have only 1 planning entity class.</para>

      <note>
        <para>In <link linkend="realTimePlanning">real-time planning</link>, problem facts can change during planning,
        because the problem itself changes. That doesn't make them planning entities.</para>
      </note>

      <para><emphasis role="bold">In Drools Planner all problems facts and planning entities are plain old JavaBeans
      (POJO's).</emphasis> You can load them from a database (JDBC/JPA/JDO), an XML file, a data repository, a noSQL
      cloud, ...: Drools Planner doesn't care.</para>
    </section>

    <section>
      <title>Implementing a planning entity</title>

      <section>
        <title>The planning entity class</title>

        <para>TODO</para>

        <programlisting>@PlanningEntity
public class Queen {
    ...
}</programlisting>

        <para>ggg</para>

        <important>
          <para>Avoid changing classes during planning that are not real planning entities or logical insertions. So
          avoid having more than 1 planning entity class (or 1 planning entity class hierarchy), unless the problem
          requires it. TODO</para>
        </important>
      </section>

      <section>
        <title>Planning entity difficulty comparison</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Planning variable</title>

        <para>TODO</para>
      </section>

      <section>
        <title>Planning value</title>

        <para>TODO</para>
      </section>

      <section>
        <title>ValueRange</title>

        <section>
          <title><literal>ValueRangeFromSolutionProperty</literal></title>

          <para>TODO</para>

          <para>todo should range include null or not?</para>
        </section>

        <section>
          <title><literal>ValueRangeFromPlanningEntityProperty</literal></title>

          <para>TODO</para>
        </section>

        <section>
          <title><literal>ValueRangeUndefined</literal></title>

          <para>TODO</para>
        </section>
      </section>

      <section>
        <title>Planning value strength comparison</title>

        <para>TODO</para>
      </section>
    </section>
  </section>

  <section>
    <title>The <literal>Solution</literal> interface</title>

    <para>You need to present the problem as a starting <literal>Solution</literal> instance to the solver.</para>

    <para>This means you need to implement the <literal>Solution</literal> interface:</para>

    <programlisting language="java">public interface Solution&lt;S extends Score&gt; {

    S getScore();
    void setScore(S score);

    Collection&lt;? extends Object&gt; getProblemFacts();

    Solution&lt;S&gt; cloneSolution();

}</programlisting>

    <para>For example, an <literal>NQueens</literal> instance holds a list of all columns, all rows and all
    <literal>Queen</literal> instances:</para>

    <programlisting language="java">public class NQueens implements Solution&lt;SimpleScore&gt; {

    private int n;

    // Problem facts
    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    // Planning entities
    private List&lt;Queen&gt; queenList;

    // ...

}</programlisting>

    <section>
      <title>The getScore and setScore methods</title>

      <para>A <literal>Solution</literal> requires a score property. The score property is null if the
      <literal>Solution</literal> is uninitialized or if the score has not yet been (re)calculated. The score property
      is usually typed to the specific <literal>Score</literal> implementation you use. For example,
      <literal>NQueens</literal> uses a <literal>SimpleScore</literal>:</para>

      <programlisting language="java">    private SimpleScore score;

    public SimpleScore getScore() {
        return score;
    }

    public void setScore(SimpleScore score) {
        this.score = score;
    }</programlisting>

      <para>Most use cases use a <literal>HardAndSoftScore</literal> instead:</para>

      <programlisting>    private HardAndSoftScore score;</programlisting>
    </section>

    <section>
      <title>The getProblemFacts method</title>

      <para>All objects returned by the <literal>getProblemFacts()</literal> method will be asserted into the drools
      working memory. Those facts can be used by the score rules. For example, <literal>NQueens</literal> just returns
      all <literal>Queen</literal> instances.</para>

      <programlisting language="java">    public Collection&lt;? extends Object&gt; getProblemFacts() {
        List&lt;Object&gt; facts = new ArrayList&lt;Object&gt;();
        facts.addAll(columnList);
        facts.addAll(rowList);
        // Do not add the planning entity's (queenList) because that will be done automatically
        return facts;
    }</programlisting>
    </section>

    <section>
      <title>The cloneSolution method</title>

      <para>Most solver algorithms use the <literal>cloneSolution()</literal> method to clone the solution each time
      they encounter a new best solution, so they can recall it later.</para>

      <para>The <literal>NQueens</literal> implementation only deep clones all <literal>Queen</literal> instances, so
      when the original solution is changed during planning, by changing a <literal>Queen</literal>, the clone stays the
      same.</para>

      <programlisting language="java">    /**
     * Clone will only deep copy the {@link #queenList}.
     */
    public NQueens cloneSolution() {
        NQueens clone = new NQueens();
        clone.id = id;
        clone.n = n;
        clone.columnList = columnList;
        clone.rowList = rowList;
        List&lt;Queen&gt; clonedQueenList = new ArrayList&lt;Queen&gt;(queenList.size());
        for (Queen queen : queenList) {
            clonedQueenList.add(queen.clone());
        }
        clone.queenList = clonedQueenList;
        clone.score = score;
        return clone;
    }</programlisting>

      <para>The <literal>cloneSolution()</literal> method should only deep clone the planning entities. Notice that the
      problem facts, such as <literal>Column</literal> and <literal>Row</literal> are normally <emphasis>not</emphasis>
      cloned: even their <literal>List</literal> instances are <emphasis>not</emphasis> cloned.</para>

      <note>
        <para>If you were to clone the problem facts too, then you'd have to make sure that the new planning entity
        clones also refer to the new problem facts clones used by the solution. For example, if you 'd clone all
        <literal>Row</literal> instances, then each <literal>Queen</literal> clone and the <literal>NQueens</literal>
        clone itself should refer to the same set of new <literal>Row</literal> clones.</para>
      </note>
    </section>
  </section>

  <section>
    <title>The Solver interface</title>

    <para>This is the <literal>Solver</literal> interface, which you 'll build from a solver configuration:</para>

    <programlisting language="java">public interface Solver {

    void setStartingSolution(Solution solution);
    
    void solve();

    Solution getBestSolution();

    // ...

}</programlisting>

    <para>A Solver can only solve 1 problem instance at a time. A <literal>Solver</literal> should only be accessed from
    a single thread, except for the methods that are specifically javadocced as thread-safe.</para>
  </section>

  <section>
    <title>Building a Solver</title>

    <para>You can build a <literal>Solver</literal> instance with the <literal>XmlSolverConfigurer</literal>. Configure
    it with a solver configuration XML file:</para>

    <programlisting language="java">    XmlSolverConfigurer configurer = new XmlSolverConfigurer();
    configurer.configure("/org/drools/planner/examples/nqueens/solver/nqueensSolverConfig.xml");
    Solver solver = configurer.buildSolver();</programlisting>

    <para>A basic solver configuration file looks something like this:</para>

    <programlisting language="xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver&gt;
  &lt;environmentMode&gt;DEBUG&lt;/environmentMode&gt;
  &lt;solutionClass&gt;org.drools.planner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;planningEntityClass&gt;org.drools.planner.examples.nqueens.domain.Queen&lt;/planningEntityClass&gt;
  &lt;scoreDrl&gt;/org/drools/planner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
  &lt;scoreDefinition&gt;
    &lt;scoreDefinitionType&gt;SIMPLE&lt;/scoreDefinitionType&gt;
  &lt;/scoreDefinition&gt;
  &lt;termination&gt;
    &lt;scoreAttained&gt;0&lt;/scoreAttained&gt;
  &lt;/termination&gt;
  &lt;!-- Real world problems require to use of &lt;constructionHeuristic&gt;. --&gt;
  &lt;localSearch&gt;
    &lt;selector&gt;
      &lt;moveFactoryClass&gt;org.drools.planner.examples.nqueens.solver.move.factory.RowChangeMoveFactory&lt;/moveFactoryClass&gt;
    &lt;/selector&gt;
    &lt;acceptor&gt;
      &lt;completeSolutionTabuSize&gt;1000&lt;/completeSolutionTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;pickEarlyType&gt;NEVER&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;
&lt;/solver&gt;</programlisting>

    <para>This is a tabu search configuration for n queens. We 'll explain the various parts of a configuration later in
    this manual.</para>

    <para><emphasis role="bold">Drools Planner makes it relatively easy to switch a solver type just by changing the
    configuration.</emphasis> There's even a <literal>Benchmark</literal> utility which allows you to play out different
    configurations against each other and report the most appropriate configuration for your problem. You could for
    example play out tabu search versus simulated annealing, on 4 queens and 64 queens.</para>

    <section>
      <title>Environment mode</title>

      <para>A solver has a single <literal>Random</literal> instance. Some solver configurations use the
      <literal>Random</literal> instance a lot more than others. For example simulated annealing depends highly on
      random numbers, while tabu search only depends on it to deal with score ties. The environment mode influences the
      seed of that <literal>Random</literal> instance.</para>

      <para>The environment mode also allows you to detect common bugs in your implementation.</para>

      <para>You can set the environment mode in the solver configuration XML file:</para>

      <programlisting language="xml">&lt;solver&gt;
  &lt;environmentMode&gt;DEBUG&lt;/environmentMode&gt;
  ...
&lt;/solver&gt;</programlisting>

      <para>There are 4 environment modes:</para>

      <section>
        <title>TRACE</title>

        <para>The trace mode is reproducible (see the reproducible mode) and also turns on all assertions (such as
        assert that the delta based score is uncorrupted) to fail-fast on rule engine bugs.</para>

        <para>The trace mode is very slow (because it doesn't rely on delta based score calculation).</para>
      </section>

      <section>
        <title>DEBUG</title>

        <para>The debug mode is reproducible (see the reproducible mode) and also turns on most assertions (such as
        assert that the undo Move is uncorrupted) to fail-fast on a bug in your Move implementation, your score rule,
        ...</para>

        <para>The debug mode is slow.</para>

        <para>It's recommended to write a test case which does a short run of your planning problem with debug mode
        on.</para>
      </section>

      <section>
        <title>REPRODUCIBLE (default)</title>

        <para>The reproducible mode is the default mode because it is recommended during development. In this mode, 2
        runs on the same computer will execute the same code in the same order. They will also yield the same result,
        except if they use a time based termination and they have a sufficiently large difference in allocated CPU time.
        This allows you to benchmark new optimizations (such as a new move implementation or a different
        minimalAcceptedSelection setting) fairly.</para>

        <para>The reproducible mode is not much slower than the production mode.</para>

        <para>In practice, this mode uses the default random seed, and it also disables certain concurrency
        optimizations (such as work stealing).</para>
      </section>

      <section>
        <title>PRODUCTION</title>

        <para>The production mode is the fastest and the most robust, but not reproducible. It is recommended for a
        production environment.</para>

        <para>The random seed is different on every run, which makes it more robust against an unlucky random seed. An
        unlucky random seed gives a bad result on a certain data set with a certain solver configuration. Note that in
        most use cases the impact of the random seed is relatively low on the result (even with simulated annealing). An
        occasional bad result is far more likely caused by another issue (such as a score trap).</para>
      </section>
    </section>
  </section>

  <section>
    <title>The starting solution</title>

    <para>First, you will need to make a starting solution and set that on the solver:</para>

    <programlisting language="java">solver.setStartingSolution(startingSolution);</programlisting>

    <section>
      <title>A simple filler algorithm</title>

      <para>For 4 queens we use a simple filler algorithm that creates a starting solution with all queens on a
      different x and on the same y (with y = 0).</para>

      <figure>
        <title>Starting solution for the 4 queens puzzle</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Chapter-Planner_configuration/unsolvedNQueens04.png" format="PNG"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>Here's how we generate it:</para>

      <programlisting language="java">    private NQueens createNQueens(int n) {
        NQueens nQueens = new NQueens();
        nQueens.setId(0L);
        nQueens.setN(n);
        List&lt;Queen&gt; queenList = new ArrayList&lt;Queen&gt;(n);
        for (int x = 0; x &lt; n; x++) {
            Queen queen = new Queen();
            queen.setId((long) x);
            queen.setX(x);
            // Notice that we leave the PlanningVariable properties on null: no setY()
            queenList.add(queen);
        }
        nQueens.setQueenList(queenList);
        return nQueens;
    }</programlisting>

      <para>The starting solution will probably be far from optimal (or even feasible). Here, it's actually the worst
      possible solution. However, we 'll let the solver find a much better solution for us anyway.</para>
    </section>
  </section>

  <section>
    <title>Solving a problem</title>

    <para>Solving a problem is quite easy once you have a solver and the starting solution:</para>

    <programlisting language="java">    solver.setStartingSolution(startingSolution);
    solver.solve();
    Solution bestSolution = solver.getBestSolution();</programlisting>

    <para>The <literal>solve()</literal> method will take a long time (depending on the problem size and the solver
    configuration). The solver will remember (actually clone) the best solution it encounters during its solving.
    Depending on a number factors (including problem size, how long you allow the solver to work, which solver type you
    use, ...), that best solution will be a feasible or even an optimal solution.</para>

    <figure>
      <title>Best solution for the 4 queens puzzle (also an optimal solution)</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Chapter-Planner_configuration/solvedNQueens04.png" format="PNG"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>After a problem is solved, you can reuse the same solver instance to solve another problem (of the same
    problem type).</para>
  </section>
</chapter>
